var gulp = require('gulp'),
    uglify = require('uglify-to-browserify'),
    browserify = require('browserify'),
    cache,
    concatCss = require('gulp-concat-css'),
    jscs,
    jshint,
    livereload,
    minifyCss = require('gulp-minify-css'),
    plumber,
    prefixer = require('gulp-autoprefixer'),
    remember,
    rename = require('gulp-rename'),
    rimraf,
    sass = require('gulp-sass'),
    source = require('vinyl-source-stream'),
    stylish,
    uglify = require('gulp-uglify'),
    watchify,

    production = process.env.NODE_ENV === 'production',

    path = {
        src: {
            all: 'src/**/*',
            js: 'src/**/*.js',
            client: {
                main: './src/client/js/main.js',
                scss: 'src/client/**/*.s[ac]ss',
                static: [
                    'src/client/resources/**/*',
                    'src/client/exercises/**/*',
                    'src/client/index.html'
                ]
            },
            server: 'src/server/**/*'
        },
        dist: {
            base: 'dist/',
            all: 'dist/**/*',
            client: 'dist/client/',
            server: 'dist/server/',
            serverMain: 'dist/server/main.js'
        }
    },

    watching;

if ( !production ) {
    cache = require('gulp-cached');
    jscs = require('gulp-jscs');
    jshint = require('gulp-jshint');
    livereload = require('gulp-livereload');
    plumber = require('gulp-plumber');
    remember = require('gulp-remember');
    rimraf = require('rimraf');
    stylish = require('jshint-stylish');
    watchify = require('watchify');
}

// *~ is generated by vim as temp file when saving atomically
function notilde( path ) {
    return [].concat( path, '!**/*~' );
}

gulp.task( 'build', [ 'sass', 'browserify', 'collectstatic', 'collectserver' ] );
gulp.task( 'default', [ 'checkstyle', 'watch', 'build' ] );

gulp.task( 'clean', function( cb ) {
    rimraf( path.dist.base, cb );
});

gulp.task( 'checkstyle', function() {
    var stream = gulp.src( path.src.js )

    if ( !production ) {
        stream = stream
            .pipe( plumber() )
            .pipe( cache('scripts') );
    }

    stream.pipe( jscs() )
        .pipe( jshint() )
        .pipe( jshint.reporter( stylish ) );
});

gulp.task( 'sass', function() {
    var stream = gulp.src( path.src.client.scss )

    if ( !production ) {
        stream = stream
            .pipe( plumber() )
            .pipe( cache('styles') )
    }

    stream = stream.pipe( sass() );

    if( !production ) {
        stream = stream.pipe( remember('styles') );
    }

    stream.pipe( minifyCss({ cache: true }) )
        .pipe( concatCss('bundle.css') )
        .pipe( prefixer('> 5%') )
        .pipe( gulp.dest( path.dist.client ) );
});

gulp.task( 'browserify', function() {
    var bundler = browserify({
        cache: {}, packageCache: {}, fullPaths: true,
        entries: path.src.client.main,
        debug: !production
    });

    var bundle = function() {
        return bundler
            .bundle()
            .pipe( source('bundle.js') )
            .pipe( gulp.dest( path.dist.client ) );
    };

    if ( watching ) {
        bundler = watchify( bundler );
        bundler.on( 'update', bundle );
    }

    return bundle();
});

gulp.task( 'collectstatic', function() {
    var stream = gulp.src( notilde( path.src.client.static ) )

    if( !production ) {
        stream = stream.pipe( cache('static') );
    }

    stream.pipe( gulp.dest( path.dist.client ) );
});

gulp.task( 'collectserver', function() {
    var stream = gulp.src( notilde( path.src.server ) )

    if( !production ) {
        stream = stream.pipe( cache('server') );
    }

    stream.pipe( gulp.dest( path.dist.server ) );
});

gulp.task( 'watch', function() {
    watching = true;
    gulp.watch( notilde( path.src.js ), [ 'checkstyle' ] );
    gulp.watch( notilde( path.src.client.scss ), [ 'sass' ] );
    gulp.watch( notilde( path.src.client.static ), [ 'collectstatic' ] );
    gulp.watch( notilde( path.src.server ), [ 'collectserver' ] );
    gulp.watch( path.dist.all ).on( 'change', livereload.changed );
});
